# Bootloader

bootloader 框架

## [方案一](#方案一_引导集成联网功能)

## [方案二](#方案二_不集成联网功能,只实现引导功能)

## [升级流程](#升级流程_Tag)





## 方案一_引导集成联网功能

​	此方案,是Boot loader中集成WiFi、NBIOT、USB、LCD等的驱动，在引导过程中完成联网检查、同时集成相关的升级功能；

### 优点

* Boot过程中可以完成全部升级流程
* 独立完成全部流程，当APP分区错误时可以联网自动修复
* 省去下载完成后升级过程中，Flash中多个分区跳转和信号量传递
* 功能完全解耦，首次烧录只需要一个Bootloader，剩余可以全离线完成

### 缺点

* 集成多个硬件驱动，导致的引导程序代码冗余
* 可能存在的重复的硬件多次初始化，延长机器启动时间

## 方案二_不集成联网功能,只实现引导功能

​	此方案，在Bootloader中不集成额外功能，只保留基础的Flash、UART、LCD（待定）的驱动，只完成固件刷写；

### 优点

* 代码轻量化、更小的空间占用
* 网络相关的硬件驱动可以同主程序共用
* 简化硬件初始化流程，加快启动速度
* 不集成驱动，功能可裁剪更灵活
* 升级流程也更灵活

### 缺点

* Bootloader依赖与主APP的功能与驱动，不能单独使用

* 主程序检查升级后需要重新跳转到引导区，存在信号量传递问题（Flash传递或者不断电RAM传递；

### 方案确定

  	考虑到，WiFi驱动、NBIOT驱动大小，和后端对接升级流程，感觉在运行中检查升级然后选择是否升级更合理；

​	升级完成后不主动删除下载分区的内容，当出现升级失败之后或者预留触发方式重新启动升级流程（或者回复之前版本）；避免因为主APP分区错误导致无法恢复的问题；

​	同时因为再APP中，网络部分的初始化和保证啥的不用单独保障，依赖存在的代码框架就行；



## 升级流程_Tag

 * 在启动后检查本地下载区是否又待升级固件

 * 拉取当前服务器中的固件信息，判断是否、能够升级；

   固件信息：要含有 升级类型（推荐、可选、强制几种类型），版本号，固件大小，升级内容等；

 * 交给用户决定是否升级，通过消息推送渠道和主机显示屏提醒用户；

 * 升级确认后，开始下载固件（推荐升级固件在闲置时提前下载）；

 * 下载完成进行MD5校验；

 * 校验完成，在RAM传递升级信号（不断电），软重启后Bootloader完成剩余二进制文件复写工作，完成后进入新的APP，下载区的代码不进行主动清除。因为版本号判断，不会影响启动的检查；

 * 如果升级出现问题，如APP区损坏、升级过程断电；则通过触发（长按按键）Bootloader 的恢复机制，将下载区的代码恢复到主分区。这同时也是中断升级恢复的功能；


